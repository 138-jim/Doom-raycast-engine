diff --git a/Python/doom.py b/Python/doom.py
index 8857d0f..b6a6f7b 100644
--- a/Python/doom.py
+++ b/Python/doom.py
@@ -48,6 +48,48 @@ WALL_STRIP_WIDTH = math.ceil(SCREEN_WIDTH / RAY_COUNT)  # Ensure no gaps between
 
 # Weapon settings
 WEAPON_IDLE_POS = 0
+
+# Weapon configurations for different weapon types
+WEAPON_CONFIGS = {
+    'pistol': {
+        'name': 'PISTOL',
+        'max_ammo': 12,
+        'damage': 1,
+        'fire_cooldown': 20,
+        'reload_time': 150,
+        'recoil': 10,
+        'recoil_recovery': 0.08,
+        'spread': 0,  # No spread
+        'pellets': 1,  # Single bullet
+        'auto': False  # Semi-automatic
+    },
+    'shotgun': {
+        'name': 'SHOTGUN',
+        'max_ammo': 8,
+        'damage': 1,
+        'fire_cooldown': 40,
+        'reload_time': 200,
+        'recoil': 25,
+        'recoil_recovery': 0.06,
+        'spread': 0.15,  # Wide spread angle
+        'pellets': 5,  # 5 pellets per shot
+        'auto': False
+    },
+    'rifle': {
+        'name': 'RIFLE',
+        'max_ammo': 30,
+        'damage': 1,
+        'fire_cooldown': 8,
+        'reload_time': 180,
+        'recoil': 6,
+        'recoil_recovery': 0.12,
+        'spread': 0.05,  # Slight spread
+        'pellets': 1,
+        'auto': True  # Fully automatic
+    }
+}
+
+# Legacy constants for backwards compatibility
 WEAPON_RECOIL = 10
 WEAPON_RECOIL_RECOVERY_SPEED = 0.08
 WEAPON_FIRE_COOLDOWN = 20  # frames
@@ -360,48 +402,68 @@ def load_textures():
 
 # Create a gun class to handle weapon logic
 class Gun:
-    def __init__(self):
+    def __init__(self, weapon_type='pistol'):
+        self.weapon_type = weapon_type
+        self.config = WEAPON_CONFIGS[weapon_type]
+
         self.recoil = 0
         self.firing = False
         self.cooldown = 0
         self.flash_duration = 0
-        self.ammo = WEAPON_MAX_AMMO
+        self.ammo = self.config['max_ammo']
         self.reloading = False
         self.reload_timer = 0
-        
+        self.hit_data = []  # Store hit information for spread weapons
+
         # Load weapon graphics
         self.weapon_image = self.create_weapon_image()
         self.muzzle_flash = self.create_muzzle_flash()
-        
+
         # Load sound effects
         mixer.init()
         self.sound_fire = mixer.Sound(os.path.join("sounds", "gun_fire.wav"))
         self.sound_empty = mixer.Sound(os.path.join("sounds", "gun_empty.wav"))
         self.sound_reload = mixer.Sound(os.path.join("sounds", "gun_reload.wav"))
-        
+
         # Set volume
         self.sound_fire.set_volume(0.3)
         self.sound_empty.set_volume(0.3)
         self.sound_reload.set_volume(0.3)
     
     def create_weapon_image(self):
-        # Create a simple gun image
+        # Create weapon image based on type
         gun_surface = Surface((150, 120), pygame.SRCALPHA)
-        
-        # Gun barrel
-        pygame.draw.rect(gun_surface, (50, 50, 50), (60, 20, 40, 10))
-        
-        # Gun body
-        pygame.draw.rect(gun_surface, (70, 70, 70), (40, 30, 70, 40))
-        pygame.draw.rect(gun_surface, (60, 60, 60), (50, 70, 50, 30))
-        
-        # Gun handle
-        pygame.draw.rect(gun_surface, (80, 50, 30), (60, 70, 30, 50))
-        
-        # Gun details
-        pygame.draw.rect(gun_surface, (100, 100, 100), (45, 35, 60, 10))
-        pygame.draw.rect(gun_surface, (30, 30, 30), (95, 25, 10, 5))
-        
+
+        if self.weapon_type == 'pistol':
+            # Pistol - compact handgun
+            pygame.draw.rect(gun_surface, (50, 50, 50), (60, 20, 40, 10))  # Barrel
+            pygame.draw.rect(gun_surface, (70, 70, 70), (40, 30, 70, 40))  # Body
+            pygame.draw.rect(gun_surface, (60, 60, 60), (50, 70, 50, 30))  # Lower body
+            pygame.draw.rect(gun_surface, (80, 50, 30), (60, 70, 30, 50))  # Handle
+            pygame.draw.rect(gun_surface, (100, 100, 100), (45, 35, 60, 10))  # Details
+            pygame.draw.rect(gun_surface, (30, 30, 30), (95, 25, 10, 5))  # Sight
+
+        elif self.weapon_type == 'shotgun':
+            # Shotgun - wider barrel, pump action
+            pygame.draw.rect(gun_surface, (40, 40, 40), (50, 15, 60, 18))  # Wide barrel
+            pygame.draw.rect(gun_surface, (35, 35, 35), (70, 33, 20, 8))  # Pump
+            pygame.draw.rect(gun_surface, (60, 60, 60), (30, 35, 80, 45))  # Body
+            pygame.draw.rect(gun_surface, (50, 50, 50), (40, 80, 60, 25))  # Lower receiver
+            pygame.draw.rect(gun_surface, (70, 45, 25), (55, 80, 30, 40))  # Wooden stock
+            pygame.draw.rect(gun_surface, (90, 90, 90), (35, 40, 70, 12))  # Top rail
+            pygame.draw.rect(gun_surface, (25, 25, 25), (105, 20, 8, 8))  # Front sight
+
+        elif self.weapon_type == 'rifle':
+            # Rifle - long barrel, tactical look
+            pygame.draw.rect(gun_surface, (45, 45, 45), (50, 18, 70, 12))  # Long barrel
+            pygame.draw.rect(gun_surface, (55, 55, 55), (25, 30, 90, 35))  # Body
+            pygame.draw.rect(gun_surface, (50, 50, 50), (35, 65, 70, 30))  # Lower receiver
+            pygame.draw.rect(gun_surface, (65, 40, 30), (50, 75, 40, 45))  # Stock
+            pygame.draw.rect(gun_surface, (80, 80, 80), (30, 35, 80, 8))  # Top rail
+            pygame.draw.rect(gun_surface, (100, 100, 100), (60, 33, 30, 4))  # Scope mount
+            pygame.draw.rect(gun_surface, (30, 30, 30), (115, 22, 6, 6))  # Front sight
+            pygame.draw.rect(gun_surface, (40, 40, 40), (80, 60, 25, 8))  # Magazine
+
         return gun_surface
     
     def create_muzzle_flash(self):
@@ -426,55 +488,69 @@ class Gun:
     def fire(self):
         if self.cooldown == 0 and not self.reloading:
             if self.ammo > 0:
-                # Trigger recoil
-                self.recoil = WEAPON_RECOIL
+                # Trigger recoil using weapon config
+                self.recoil = self.config['recoil']
                 self.firing = True
-                self.cooldown = WEAPON_FIRE_COOLDOWN
+                self.cooldown = self.config['fire_cooldown']
                 self.flash_duration = 4
-                
+
                 # Reduce ammo
                 self.ammo -= 1
-                
+
+                # Generate spread pattern for multiple pellets (shotgun)
+                self.hit_data = []
+                for i in range(self.config['pellets']):
+                    # Calculate spread offset for this pellet
+                    if self.config['spread'] > 0:
+                        spread_angle = random.uniform(-self.config['spread'], self.config['spread'])
+                    else:
+                        spread_angle = 0
+                    self.hit_data.append({
+                        'angle_offset': spread_angle,
+                        'damage': self.config['damage']
+                    })
+
                 # Play sound
                 self.sound_fire.play()
-                
+
                 return True
             else:
                 # Empty gun click
                 self.sound_empty.play()
-                self.cooldown = WEAPON_FIRE_COOLDOWN // 2  # Shorter cooldown for empty
-                
+                self.cooldown = self.config['fire_cooldown'] // 2  # Shorter cooldown for empty
+
                 return False
         return False
     
     def reload(self):
-        if not self.reloading and self.ammo < WEAPON_MAX_AMMO:
+        if not self.reloading and self.ammo < self.config['max_ammo']:
             self.reloading = True
-            self.reload_timer = WEAPON_RELOAD_TIME
+            self.reload_timer = self.config['reload_time']
             self.sound_reload.play()
-    
+
     def update(self):
-        # Handle recoil recovery
+        # Handle recoil recovery using weapon config
         if self.recoil > 0:
-            self.recoil -= WEAPON_RECOIL_RECOVERY_SPEED
+            self.recoil -= self.config['recoil_recovery']
             if self.recoil < 0:
                 self.recoil = 0
-        
+
         # Handle cooldown
         if self.cooldown > 0:
             self.cooldown -= 1
             if self.cooldown == 0:
                 self.firing = False
-        
+                self.hit_data = []  # Clear hit data when firing ends  
+
         # Handle muzzle flash
         if self.flash_duration > 0:
             self.flash_duration -= 1
-        
+
         # Handle reloading
         if self.reloading:
             self.reload_timer -= 1
             if self.reload_timer <= 0:
-                self.ammo = WEAPON_MAX_AMMO
+                self.ammo = self.config['max_ammo']
                 self.reloading = False
     
     def draw(self, screen):
@@ -483,25 +559,33 @@ class Gun:
         weapon_height = self.weapon_image.get_height()
         weapon_x = SCREEN_WIDTH // 2 - weapon_width // 2
         weapon_y = SCREEN_HEIGHT - weapon_height + int(self.recoil)
-        
+
         # Draw weapon
         screen.blit(self.weapon_image, (weapon_x, weapon_y))
-        
+
         # Draw muzzle flash when firing
         if self.flash_duration > 0:
             flash_x = weapon_x + 100
             flash_y = weapon_y + 25
             screen.blit(self.muzzle_flash, (flash_x, flash_y))
-        
-        # Draw ammo counter
+
+        # Draw weapon name and ammo counter
         font = pygame.font.SysFont(None, 30)
-        ammo_text = font.render(f"AMMO: {self.ammo}/{WEAPON_MAX_AMMO}", True, (255, 255, 255))
-        screen.blit(ammo_text, (SCREEN_WIDTH - 150, SCREEN_HEIGHT - 30))
-        
+        weapon_name_text = font.render(self.config['name'], True, (255, 255, 100))
+        screen.blit(weapon_name_text, (SCREEN_WIDTH - 150, SCREEN_HEIGHT - 90))
+
+        ammo_text = font.render(f"AMMO: {self.ammo}/{self.config['max_ammo']}", True, (255, 255, 255))
+        screen.blit(ammo_text, (SCREEN_WIDTH - 150, SCREEN_HEIGHT - 60))
+
         # Show reloading text
         if self.reloading:
             reload_text = font.render("RELOADING...", True, (255, 200, 50))
-            screen.blit(reload_text, (SCREEN_WIDTH - 150, SCREEN_HEIGHT - 60))
+            screen.blit(reload_text, (SCREEN_WIDTH - 150, SCREEN_HEIGHT - 30))
+
+        # Show weapon switch hint
+        hint_font = pygame.font.SysFont(None, 20)
+        hint_text = hint_font.render("1: PISTOL  2: SHOTGUN  3: RIFLE", True, (150, 150, 150))
+        screen.blit(hint_text, (10, SCREEN_HEIGHT - 25))
 
 # Player class
 class Player:
@@ -917,36 +1001,48 @@ class EnemyManager:
                     # Handle player death if needed
             
             # Check if player is shooting this enemy
-            if gun.firing:
-                # Improved hit detection
+            if gun.firing and gun.hit_data:
+                # Calculate enemy position relative to player
                 dx = enemy.x - player.x
                 dy = enemy.y - player.y
                 distance = math.sqrt(dx*dx + dy*dy)
-                
+
                 # Check if player is looking at enemy (angle check)
                 enemy_angle = math.degrees(math.atan2(dy, dx))
                 # Normalize angles for comparison
                 enemy_angle = (enemy_angle + 360) % 360
-                player_angle = (player.angle + 360) % 360
-                
-                # Calculate angle difference with proper wrapping
-                angle_diff = min(abs(enemy_angle - player_angle), 
-                               abs(enemy_angle - player_angle + 360),
-                               abs(enemy_angle - player_angle - 360))
-                
-                # Make the hit detection more forgiving
-                hit_angle_threshold = HALF_FOV * 1.2
+
+                # Check each pellet/bullet in the spread pattern
                 hit_distance_threshold = TILE_SIZE * 8
-                
-                # Check if enemy is in front of player and within view angle
-                if distance < hit_distance_threshold and angle_diff < hit_angle_threshold:
-                    enemy_killed = enemy.take_damage()
-                    if enemy_killed:
-                        self.enemies.remove(enemy)
-                        player.score += 100
-                        
-                        # Provide feedback text
-                        print(f"Enemy killed! Total enemies: {len(self.enemies)}")
+                enemy_hit = False
+
+                for hit in gun.hit_data:
+                    # Apply angle offset for this pellet
+                    pellet_angle = (math.degrees(player.angle) + math.degrees(hit['angle_offset']) + 360) % 360
+
+                    # Calculate angle difference with proper wrapping
+                    angle_diff = min(abs(enemy_angle - pellet_angle),
+                                   abs(enemy_angle - pellet_angle + 360),
+                                   abs(enemy_angle - pellet_angle - 360))
+
+                    # Make the hit detection forgiving based on distance
+                    hit_angle_threshold = HALF_FOV * 1.2
+
+                    # Check if enemy is in front of player and within this pellet's angle
+                    if distance < hit_distance_threshold and angle_diff < hit_angle_threshold:
+                        enemy_killed = enemy.take_damage()
+                        enemy_hit = True
+                        if enemy_killed:
+                            self.enemies.remove(enemy)
+                            player.score += 100
+
+                            # Provide feedback text
+                            print(f"Enemy killed! Total enemies: {len(self.enemies)}")
+                            break  # Enemy is dead, no need to check more pellets
+
+                # Visual feedback if enemy was hit but not killed
+                if enemy_hit and enemy in self.enemies:
+                    pass  # Enemy was hit (damage applied in take_damage)
         
         # Spawn new enemies if needed
         self.spawn_cooldown -= 1
@@ -2109,7 +2205,15 @@ def main():
     gun = None
     textures = None
     enemy_manager = None
-    
+
+    # Weapon inventory - tracks ammo for each weapon type
+    weapon_inventory = {
+        'pistol': WEAPON_CONFIGS['pistol']['max_ammo'],
+        'shotgun': WEAPON_CONFIGS['shotgun']['max_ammo'],
+        'rifle': WEAPON_CONFIGS['rifle']['max_ammo']
+    }
+    current_weapon_type = 'pistol'
+
     # Mouse state
     mouse_visible = True
     mouse_clicked = False
@@ -2171,12 +2275,38 @@ def main():
                         running = False
                 elif event.key == pygame.K_r and game_state == GameState.PLAYING:
                     gun.reload()
+                # Weapon switching with number keys
+                elif event.key == pygame.K_1 and game_state == GameState.PLAYING:
+                    if current_weapon_type != 'pistol':
+                        weapon_inventory[current_weapon_type] = gun.ammo
+                        current_weapon_type = 'pistol'
+                        gun = Gun('pistol')
+                        gun.ammo = weapon_inventory['pistol']
+                elif event.key == pygame.K_2 and game_state == GameState.PLAYING:
+                    if current_weapon_type != 'shotgun':
+                        weapon_inventory[current_weapon_type] = gun.ammo
+                        current_weapon_type = 'shotgun'
+                        gun = Gun('shotgun')
+                        gun.ammo = weapon_inventory['shotgun']
+                elif event.key == pygame.K_3 and game_state == GameState.PLAYING:
+                    if current_weapon_type != 'rifle':
+                        weapon_inventory[current_weapon_type] = gun.ammo
+                        current_weapon_type = 'rifle'
+                        gun = Gun('rifle')
+                        gun.ammo = weapon_inventory['rifle']
                 # Restart game if game over and Enter is pressed
                 elif event.key == pygame.K_RETURN and game_state == GameState.GAME_OVER:
                     game_state = GameState.PLAYING
                     # Reset game state
                     player = Player(1.5, 1.5, 0)
-                    gun = Gun()
+                    # Reset weapon inventory
+                    weapon_inventory = {
+                        'pistol': WEAPON_CONFIGS['pistol']['max_ammo'],
+                        'shotgun': WEAPON_CONFIGS['shotgun']['max_ammo'],
+                        'rifle': WEAPON_CONFIGS['rifle']['max_ammo']
+                    }
+                    current_weapon_type = 'pistol'
+                    gun = Gun('pistol')
                     enemy_manager = EnemyManager()
                     # Hide mouse cursor again
                     pygame.mouse.set_visible(False)
@@ -2212,16 +2342,23 @@ def main():
                 print("Loading textures...")
                 textures = load_textures()
                 print("Textures loaded.")
-                
+
                 player = Player(1.5, 1.5, 0)
-                gun = Gun()
+                # Reset weapon inventory
+                weapon_inventory = {
+                    'pistol': WEAPON_CONFIGS['pistol']['max_ammo'],
+                    'shotgun': WEAPON_CONFIGS['shotgun']['max_ammo'],
+                    'rifle': WEAPON_CONFIGS['rifle']['max_ammo']
+                }
+                current_weapon_type = 'pistol'
+                gun = Gun('pistol')
                 enemy_manager = EnemyManager()
-                
+
                 # Hide mouse cursor for gameplay
                 pygame.mouse.set_visible(False)
                 mouse_visible = False
                 pygame.event.set_grab(True)
-                
+
                 game_state = GameState.PLAYING
             elif next_state == GameState.OPTIONS:
                 game_state = GameState.OPTIONS
@@ -2244,8 +2381,13 @@ def main():
             # Calculate mouse movement for rotation
             mouse_dx = pygame.mouse.get_rel()[0]
             
-            # Check for space bar for shooting
+            # Check for space bar for shooting (auto fire if weapon supports it)
             if keys[pygame.K_SPACE]:
+                if gun.config['auto']:
+                    gun.fire()  # Keep firing if held down
+
+            # Check for mouse button hold for auto fire
+            if mouse_held and gun.config['auto']:
                 gun.fire()
             
             # Update player with mouse movement
